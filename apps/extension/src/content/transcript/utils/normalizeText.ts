/**
 * Text Normalization Utilities
 * 
 * Clean and normalize caption text from various sources.
 */

/**
 * HTML entity map for decoding
 */
const HTML_ENTITIES: Record<string, string> = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&#39;': "'",
  '&apos;': "'",
  '&quot;': '"',
  '&nbsp;': ' ',
  '&#x27;': "'",
  '&#x2F;': '/',
  '&#x60;': '`',
  '&#x3D;': '=',
};

/**
 * Decode HTML entities in text
 */
function decodeHTMLEntities(text: string): string {
  let result = text;
  
  // Replace named and numeric entities
  for (const [entity, char] of Object.entries(HTML_ENTITIES)) {
    result = result.replace(new RegExp(entity, 'gi'), char);
  }
  
  // Handle numeric entities (&#123; or &#x7B;)
  result = result.replace(/&#(\d+);/g, (_, code) => 
    String.fromCharCode(parseInt(code, 10))
  );
  result = result.replace(/&#x([0-9a-fA-F]+);/g, (_, code) => 
    String.fromCharCode(parseInt(code, 16))
  );
  
  return result;
}

/**
 * Remove excessive whitespace while preserving structure
 */
function normalizeWhitespace(text: string): string {
  return text
    // Replace multiple spaces with single space
    .replace(/[ \t]+/g, ' ')
    // Remove spaces around newlines
    .replace(/\s*\n\s*/g, '\n')
    // Collapse multiple newlines
    .replace(/\n{3,}/g, '\n\n')
    // Trim
    .trim();
}

/**
 * Clean up auto-generated caption artifacts
 */
function cleanAutoGeneratedArtifacts(text: string): string {
  return text
    // Remove leading/trailing dashes often in auto-captions
    .replace(/^[-–—]\s*/g, '')
    .replace(/\s*[-–—]$/g, '')
    // Remove speaker labels like "[Speaker 1]:" but keep content markers like "[Music]"
    .replace(/\[Speaker\s*\d*\]:?\s*/gi, '')
    // Normalize quotes
    .replace(/[""]/g, '"')
    .replace(/['']/g, "'");
}

/**
 * Normalize newlines to standard format
 */
function normalizeNewlines(text: string): string {
  return text
    .replace(/\r\n/g, '\n')
    .replace(/\r/g, '\n');
}

/**
 * Main text normalization function
 * 
 * Applies all cleaning transformations to produce clean caption text.
 */
export function normalizeText(rawText: string): string {
  if (!rawText) return '';
  
  let result = rawText;
  
  // 1. Normalize newlines first
  result = normalizeNewlines(result);
  
  // 2. Decode HTML entities
  result = decodeHTMLEntities(result);
  
  // 3. Clean auto-generated artifacts
  result = cleanAutoGeneratedArtifacts(result);
  
  // 4. Normalize whitespace (but preserve intentional line breaks)
  result = normalizeWhitespace(result);
  
  return result;
}

/**
 * Light normalization - only essential cleanup
 * Used when we want to preserve more of the original formatting
 */
export function lightNormalize(rawText: string): string {
  if (!rawText) return '';
  
  let result = rawText;
  result = normalizeNewlines(result);
  result = decodeHTMLEntities(result);
  result = result.replace(/[ \t]+/g, ' ').trim();
  
  return result;
}

/**
 * Parse timestamp string to seconds
 * Handles formats: "0:05", "1:30", "1:05:30", "65.5"
 */
export function parseTimestamp(timestamp: string): number {
  // If it's already a number (as string), parse it
  if (/^\d+(\.\d+)?$/.test(timestamp.trim())) {
    return parseFloat(timestamp);
  }
  
  // Handle MM:SS or HH:MM:SS format
  const parts = timestamp.trim().split(':').map(p => parseFloat(p.trim()));
  
  if (parts.length === 3) {
    // HH:MM:SS
    const [hours, minutes, seconds] = parts;
    return hours * 3600 + minutes * 60 + seconds;
  } else if (parts.length === 2) {
    // MM:SS
    const [minutes, seconds] = parts;
    return minutes * 60 + seconds;
  } else if (parts.length === 1) {
    return parts[0];
  }
  
  return 0;
}

/**
 * Format seconds as timestamp string (for display)
 */
export function formatTimestamp(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  
  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
}
