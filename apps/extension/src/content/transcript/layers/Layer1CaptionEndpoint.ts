/**
 * Layer 1: Caption Endpoint Extraction (Primary Path)
 * 
 * The fastest and most reliable extraction method.
 * Fetches captions directly from YouTube's timedtext API using
 * caption track URLs from ytInitialPlayerResponse.
 */

import type { TranscriptSegment, TranscriptResult, CaptionTrack, TranscriptMetadata } from '@pauser/common';
import { TranscriptStatus, ExtractionLayer } from '@pauser/common';
import { parseXMLCaptions, parseJSONCaptions, isJSONCaptionFormat, mergeCloseSegments } from '../utils';

/**
 * Result from page context script
 */
export interface PlayerDataMessage {
  captionTracks: CaptionTrack[] | null;
  videoId: string | null;
  videoTitle: string | null;
  videoDuration: number | null;
}

/**
 * Select the best caption track from available tracks
 * Priority: manual captions > auto-generated > translated
 */
export function selectBestTrack(tracks: CaptionTrack[]): CaptionTrack | null {
  if (!tracks || tracks.length === 0) {
    return null;
  }
  
  // Separate tracks by type
  const manualTracks: CaptionTrack[] = [];
  const autoTracks: CaptionTrack[] = [];
  
  for (const track of tracks) {
    if (track.kind === 'asr') {
      autoTracks.push(track);
    } else {
      manualTracks.push(track);
    }
  }
  
  // Prefer English manual captions
  const preferEnglish = (tracks: CaptionTrack[]): CaptionTrack | undefined => {
    return tracks.find(t => 
      t.languageCode === 'en' || 
      t.languageCode.startsWith('en-')
    );
  };
  
  // Try manual tracks first
  if (manualTracks.length > 0) {
    return preferEnglish(manualTracks) || manualTracks[0];
  }
  
  // Fall back to auto-generated
  if (autoTracks.length > 0) {
    return preferEnglish(autoTracks) || autoTracks[0];
  }
  
  return null;
}

/**
 * Get the language name from a caption track
 */
function getTrackLanguageName(track: CaptionTrack): string {
  if (track.name?.simpleText) {
    return track.name.simpleText;
  }
  if (track.name?.runs && track.name.runs.length > 0) {
    return track.name.runs.map(r => r.text).join('');
  }
  return track.languageCode || 'Unknown';
}

/**
 * Fetch captions from YouTube's timedtext endpoint
 */
async function fetchCaptions(track: CaptionTrack): Promise<string> {
  // Add format parameter for JSON (more structured)
  // We'll try JSON first, fall back to XML
  let url = track.baseUrl;
  
  // Ensure we get the full caption file (not just a snippet)
  if (!url.includes('fmt=')) {
    url += '&fmt=json3';
  }
  
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch captions: ${response.status}`);
    }
    return await response.text();
  } catch (error) {
    // If JSON format fails, try without format specifier (defaults to XML)
    if (url.includes('fmt=json3')) {
      const xmlUrl = track.baseUrl;
      const response = await fetch(xmlUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch captions: ${response.status}`);
      }
      return await response.text();
    }
    throw error;
  }
}

/**
 * Parse caption content (auto-detect format)
 */
function parseCaptions(content: string): TranscriptSegment[] {
  const trimmed = content.trim();
  
  if (isJSONCaptionFormat(trimmed)) {
    return parseJSONCaptions(trimmed);
  } else {
    return parseXMLCaptions(trimmed);
  }
}

/**
 * Extract transcript using Layer 1: Caption Endpoint
 */
export async function extractFromCaptionEndpoint(
  captionTracks: CaptionTrack[],
  videoId: string
): Promise<TranscriptResult> {
  try {
    // Select best track
    const selectedTrack = selectBestTrack(captionTracks);
    
    if (!selectedTrack) {
      return {
        status: TranscriptStatus.UNAVAILABLE,
        segments: [],
        metadata: null,
        error: 'No caption tracks available',
        extractionLayer: ExtractionLayer.CAPTION_ENDPOINT,
      };
    }
    
    console.log('[Pauser] Layer 1: Fetching captions from track:', selectedTrack.languageCode);
    
    // Fetch caption content
    const captionContent = await fetchCaptions(selectedTrack);
    
    // Parse captions
    let segments = parseCaptions(captionContent);
    
    if (segments.length === 0) {
      return {
        status: TranscriptStatus.ERROR,
        segments: [],
        metadata: null,
        error: 'Failed to parse caption content',
        extractionLayer: ExtractionLayer.CAPTION_ENDPOINT,
      };
    }
    
    // Merge very close segments for cleaner output
    segments = mergeCloseSegments(segments, 0.1);
    
    // Build metadata
    const isAutoGenerated = selectedTrack.kind === 'asr';
    const lastSegment = segments[segments.length - 1];
    
    const metadata: TranscriptMetadata = {
      videoId,
      language: getTrackLanguageName(selectedTrack),
      languageCode: selectedTrack.languageCode,
      isAutoGenerated,
      isTranslated: false,
      fetchedAt: Date.now(),
      totalDuration: lastSegment?.endTime || 0,
      segmentCount: segments.length,
    };
    
    console.log(`[Pauser] Layer 1: Successfully extracted ${segments.length} segments (${isAutoGenerated ? 'auto-generated' : 'manual'})`);
    
    return {
      status: TranscriptStatus.READY,
      segments,
      metadata,
      extractionLayer: ExtractionLayer.CAPTION_ENDPOINT,
    };
  } catch (error) {
    console.error('[Pauser] Layer 1 extraction failed:', error);
    return {
      status: TranscriptStatus.ERROR,
      segments: [],
      metadata: null,
      error: error instanceof Error ? error.message : 'Unknown error',
      extractionLayer: ExtractionLayer.CAPTION_ENDPOINT,
    };
  }
}
