/**
 * Pauser Background Service Worker
 *
 * Handles:
 * - State synchronization with web app API
 * - FSRS scheduling logic
 * - Cross-tab communication
 */

import { FSRSState, type FSRSCard } from '@pauser/common';

// ============================================================================
// Types
// ============================================================================

interface Message {
  type: string;
  payload?: unknown;
}

interface StatsCache {
  streak: number;
  dueCards: number;
  focusPoints: number;
  authenticated: boolean;
  lastFetched: number;
}

// ============================================================================
// Configuration
// ============================================================================

const API_BASE_URL = 'http://localhost:3000';
const CACHE_DURATION_MS = 30000; // 30 seconds

// ============================================================================
// State
// ============================================================================

/** Cards due for review (in-memory cache) */
let dueCards: FSRSCard[] = [];

/** Cached stats from API */
let statsCache: StatsCache = {
  streak: 0,
  dueCards: 0,
  focusPoints: 0,
  authenticated: false,
  lastFetched: 0
};

// ============================================================================
// API Fetching
// ============================================================================

/**
 * Fetch user stats from the web app API
 */
async function fetchStats(): Promise<StatsCache> {
  const now = Date.now();
  
  // Return cached data if still fresh
  if (now - statsCache.lastFetched < CACHE_DURATION_MS) {
    return statsCache;
  }
  
  try {
    const response = await fetch(`${API_BASE_URL}/api/stats`, {
      credentials: 'include', // Include cookies for auth
      headers: {
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      console.error('[Pauser] Failed to fetch stats:', response.status);
      return statsCache;
    }
    
    const data = await response.json();
    
    statsCache = {
      streak: data.streak || 0,
      dueCards: data.dueCards || 0,
      focusPoints: data.focusPoints || 0,
      authenticated: data.authenticated || false,
      lastFetched: now
    };
    
    console.log('[Pauser] Stats updated:', statsCache);
    return statsCache;
  } catch (error) {
    console.error('[Pauser] Error fetching stats:', error);
    return statsCache;
  }
}

// ============================================================================
// Message Handlers
// ============================================================================

// ============================================================================
// Transcript State
// ============================================================================

interface TranscriptState {
  videoId: string;
  status: string;
  segmentCount: number;
  isAutoGenerated: boolean;
  language: string;
  timestamp: number;
}

/** Cache of transcript states by video ID */
const transcriptStates: Map<string, TranscriptState> = new Map();

// ============================================================================
// Message Handlers
// ============================================================================

chrome.runtime.onMessage.addListener(
  (message: Message, sender, sendResponse: (response: unknown) => void) => {
    switch (message.type) {
      case 'GET_DUE_CARDS':
        // Fetch fresh stats and return due cards count
        fetchStats().then((stats) => {
          sendResponse({ cards: Array(stats.dueCards).fill(null), count: stats.dueCards });
        });
        return true; // Async response

      case 'GET_STREAK':
        // Fetch fresh stats and return streak
        fetchStats().then((stats) => {
          sendResponse({ streak: stats.streak, focusPoints: stats.focusPoints });
        });
        return true; // Async response

      case 'GET_ALL_STATS':
        // Get all stats at once
        fetchStats().then((stats) => {
          sendResponse(stats);
        });
        return true; // Async response

      case 'OPEN_PAUSER':
        const { videoId, time } = message.payload as { videoId: string; time: number };
        if (videoId) {
          const deepFocusUrl = `${API_BASE_URL}/deepfocus/${videoId}?t=${time}`;
          chrome.tabs.create({ url: deepFocusUrl });
        }
        sendResponse({ success: true });
        break;

      case 'OPEN_DASHBOARD':
        chrome.tabs.create({ url: `${API_BASE_URL}/dashboard` });
        sendResponse({ success: true });
        break;

      // ========================================================================
      // Transcript Messages
      // ========================================================================
      
      case 'TRANSCRIPT_READY': {
        const payload = message.payload as TranscriptState;
        if (payload?.videoId) {
          transcriptStates.set(payload.videoId, {
            ...payload,
            timestamp: Date.now(),
          });
          console.log('[Pauser] Transcript ready:', payload);
        }
        sendResponse({ success: true });
        break;
      }
      
      case 'TRANSCRIPT_ERROR': {
        const payload = message.payload as { videoId: string; error: string };
        if (payload?.videoId) {
          transcriptStates.set(payload.videoId, {
            videoId: payload.videoId,
            status: 'error',
            segmentCount: 0,
            isAutoGenerated: false,
            language: 'Unknown',
            timestamp: Date.now(),
          });
          console.error('[Pauser] Transcript error:', payload);
        }
        sendResponse({ success: true });
        break;
      }
      
      case 'GET_TRANSCRIPT': {
        // Forward request to content script in active YouTube tab
        const requestVideoId = (message.payload as { videoId?: string })?.videoId;
        
        chrome.tabs.query({ url: '*://*.youtube.com/*', active: true }, (tabs) => {
          if (tabs.length === 0) {
            sendResponse({ error: 'No YouTube tab found' });
            return;
          }
          
          chrome.tabs.sendMessage(tabs[0].id!, {
            type: 'GET_TRANSCRIPT',
            payload: { videoId: requestVideoId }
          }, (response) => {
            sendResponse(response);
          });
        });
        return true; // Async response
      }
      
      case 'GET_TRANSCRIPT_STATUS': {
        const statusVideoId = (message.payload as { videoId?: string })?.videoId;
        
        if (statusVideoId && transcriptStates.has(statusVideoId)) {
          const state = transcriptStates.get(statusVideoId)!;
          sendResponse(state);
        } else {
          // Forward to content script
          chrome.tabs.query({ url: '*://*.youtube.com/*', active: true }, (tabs) => {
            if (tabs.length === 0) {
              sendResponse({ status: 'unknown' });
              return;
            }
            
            chrome.tabs.sendMessage(tabs[0].id!, {
              type: 'GET_TRANSCRIPT_STATUS',
              payload: { videoId: statusVideoId }
            }, (response) => {
              sendResponse(response);
            });
          });
          return true; // Async response
        }
        break;
      }
      
      case 'GET_TRANSCRIPT_TEXT': {
        // Forward to content script
        chrome.tabs.query({ url: '*://*.youtube.com/*', active: true }, (tabs) => {
          if (tabs.length === 0) {
            sendResponse({ error: 'No YouTube tab found' });
            return;
          }
          
          chrome.tabs.sendMessage(tabs[0].id!, message, (response) => {
            sendResponse(response);
          });
        });
        return true; // Async response
      }

      default:
        sendResponse({ error: 'Unknown message type' });
    }

    return true;
  }
);

// ============================================================================
// Initialization
// ============================================================================

chrome.runtime.onInstalled.addListener(() => {
  console.log('[Pauser] Extension installed');

  // Initialize storage
  chrome.storage.local.set({
    initialized: true,
    installedAt: new Date().toISOString(),
  });
  
  // Pre-fetch stats on install
  fetchStats();
});

// Fetch stats when service worker starts
fetchStats();

// Log when service worker starts
console.log('[Pauser] Service worker started', { FSRSState });
